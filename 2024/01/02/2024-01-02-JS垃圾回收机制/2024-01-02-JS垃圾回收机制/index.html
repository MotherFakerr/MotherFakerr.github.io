<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="MotherFaker的个人博客"><title>JS 垃圾回收机制 | MotherFaker的个人博客</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css"><script src="/js/pace.min.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="MotherFaker的个人博客" type="application/atom+xml">
</head><body><main class="content"><section class="outer"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous"><article id="post-2024-01-02-JS垃圾回收机制/2024-01-02-JS垃圾回收机制" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal><div class="article-inner"><header class="article-header"><h1 class="article-title" itemprop="name">JS 垃圾回收机制</h1></header><div class="article-meta"><a href="/2024/01/02/2024-01-02-JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/2024-01-02-JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" class="article-date"><time datetime="2024-01-02T15:50:00.000Z" itemprop="datePublished">2024-01-02</time></a><div class="article-category"><a class="article-category-link" href="/categories/%E6%96%87%E7%AB%A0/">文章</a></div></div><div class="tocbot"></div><div class="article-entry" itemprop="articleBody"><p>当我们创建对象时，js 会在内存空间开辟地址来存放这个对象的内容。随着软件的运行，创建的对象会越来越多，而当新创建的对象不断添加，不再被使用的老对象却没有被及时清理时，内存占用就会越来越多，造成程序的运行缓慢直到崩溃。这个过程就称为<strong>内存泄漏(Memory Leak)</strong> 。</p><span id="more"></span><h1 id="一-垃圾回收算法"><a class="markdownIt-Anchor" href="#一-垃圾回收算法"></a> 一. 垃圾回收算法</h1><p><strong>垃圾回收(Garbage Collection, 简称 GC)</strong> 便是起到清理内存中不再用到的资源的手段。在一些编程语言如 C++中，程序员需要时刻关注内存使用并在适当的时候手动清理。而在 JS 中，浏览器会启用一个垃圾回收器，每过一段时间便会寻找不被使用的资源并清理，这个过程是隐藏且自动的。目前前端使用的垃圾回收机制主要有两种：<strong>引用计数法</strong>和<strong>标记清除法</strong>。</p><h2 id="11-引用计数法reference-counting"><a class="markdownIt-Anchor" href="#11-引用计数法reference-counting"></a> 1.1 引用计数法(Reference counting)</h2><h3 id="111-原理"><a class="markdownIt-Anchor" href="#111-原理"></a> 1.1.1 原理 ：</h3><p>当新变量指向对象时，该对象引用计数+1。当某一变量不再指向该对象时，引用计数-1。当引用计数为 0，清理该对象。<br><img src="/2024/01/02/2024-01-02-JS垃圾回收机制/2024-01-02-JS垃圾回收机制/images/pasted-2.png"></p><p>以图 1 为例，在 function 中创建对象以及指向该对象的两个变量，该对象同时被两个变量所引用，因此引用计数为 2。图 2 展示了退出 function 块级作用域的状态，此时 a，b 变量都被清除，对于 Object 的引用自然也被清除，Object 没有被任何东西引用，因此接下来会被垃圾回收。</p><h3 id="112-问题"><a class="markdownIt-Anchor" href="#112-问题"></a> 1.1.2 问题：</h3><p>引用计数法无法处理循环引用问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function () &#123;</span><br><span class="line">  const a = new ObjectA();</span><br><span class="line">  const b = new ObjectB();</span><br><span class="line">  // ObjectA, ObjectB被创建，引用计数都为1</span><br><span class="line">  a.object = b;</span><br><span class="line">  b.object = a;</span><br><span class="line">  // ObjectA, ObjectB互相引用，引用次数各+1都为2</span><br><span class="line">&#125;</span><br><span class="line">// 离开块级作用域，临时变量a,b被清除，ObjectA, ObjectB的引用次数各-1 = 1</span><br></pre></td></tr></table></figure><img src="/2024/01/02/2024-01-02-JS垃圾回收机制/2024-01-02-JS垃圾回收机制/images/pasted-0.png"><p>图 3 展示了 function 块内状态，ObjectA，ObjectB 除去变量 a，b 的引用外还有彼此间的一个引用，此时引用计数都为 2。而进入图 4 的状态后，来自临时变量 a，b 的引用被清除，Object 彼此间的引用仍保留。从外部来看，没有任何方法能够访问到这俩 Object，但是由于他们的引用计数不为 0，因此无法回收掉这块无效占用的内存。</p><h2 id="12-标记清除法mark-sweep"><a class="markdownIt-Anchor" href="#12-标记清除法mark-sweep"></a> 1.2 标记清除法(mark-sweep)</h2><p>标记清除法的关键字是可达性。在引用计数法最后一个例子中，互相引用的 ObjectA 和 ObjectB 无法被外部变量访问，处于不可达状态。与引用计数法通过计算引用次数不同，标记清除法会使得浏览器清空所有不可达的资源。标记清楚法能够很好的解决引用计数法造成的循环引用的问题，因此现阶段大部分主流浏览器都是使用的引用计数法。</p><h3 id="121-原理"><a class="markdownIt-Anchor" href="#121-原理"></a> 1.2.1 原理：</h3><img src="/2024/01/02/2024-01-02-JS垃圾回收机制/2024-01-02-JS垃圾回收机制/images/pasted-1.png"><p>标记清除分为三个阶段：</p><ol><li>给所有进入环境的资源打上标记</li><li>从根（一般指全局变量）开始通过引用链访问所有可达的对象并清除标记</li><li>删除所有仍拥有标记的资源。</li></ol><h1 id="二-链接"><a class="markdownIt-Anchor" href="#二-链接"></a> 二. 链接</h1><a href="/2024/01/02/2024-01-02-%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%8C%E5%BC%B1%E5%BC%95%E7%94%A8/2024-01-02-%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%8C%E5%BC%B1%E5%BC%95%E7%94%A8/" title="强引用，弱引用">强引用，弱引用传送门</a><br><a href="/2024/01/02/2024-01-02-weakMap,%20weakSet,%20weakRef/2024-01-02-weakMap,%20weakSet,%20weakRef/" title="weakMap, weakSet, weakRef">[weakSet, weakMap, weakRef 传送门]</a></div><footer class="article-footer"><a data-url="https://motherfakerr.github.io/2024/01/02/2024-01-02-JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/2024-01-02-JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" data-id="clrq183bc00090cuo83iwesyt" class="article-share-link">分享</a><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul></footer></div><nav class="article-nav"><a href="/2024/01/03/2024-01-03-%E9%A1%B5%E9%9D%A2%E5%8D%B8%E8%BD%BD%E6%97%B6%E5%90%91%E5%90%8E%E7%AB%AF%E5%8F%91%E9%80%81%E6%8E%A5%E5%8F%A3/2024-01-03-%E9%A1%B5%E9%9D%A2%E5%8D%B8%E8%BD%BD%E6%97%B6%E5%90%91%E5%90%8E%E7%AB%AF%E5%8F%91%E9%80%81%E6%8E%A5%E5%8F%A3/" class="article-nav-link"><strong class="article-nav-caption">前一篇</strong><div class="article-nav-title">页面卸载时向后端发送接口</div></a><a href="/2024/01/02/2024-01-02-%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%8C%E5%BC%B1%E5%BC%95%E7%94%A8/2024-01-02-%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%8C%E5%BC%B1%E5%BC%95%E7%94%A8/" class="article-nav-link"><strong class="article-nav-caption">后一篇</strong><div class="article-nav-title">强引用，弱引用</div></a></nav></article></section><footer class="footer"><div class="outer"><ul class="list-inline"><li>MotherFaker的个人博客 &copy; 2024</li><li><a href="https://beian.miit.gov.cn/" target="_blank"></a></li><li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li><li>theme <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li></ul><p></p><ul class="list-inline"><li><i class="fe fe-smile-alt tooltip" data-tooltip="访客量"></i> <span id="busuanzi_value_site_uv"></span></li><li><i class="fe fe-bookmark tooltip" data-tooltip="点击量"></i> <span id="busuanzi_value_page_pv"></span></li></ul><p></p></div></footer></main><aside class="sidebar"><button class="navbar-toggle"></button><nav class="navbar"><div class="logo"><a href="/"><img src="/images/logo.png" alt="MotherFaker的个人博客"></a></div><ul class="nav nav-main"><li class="nav-item"><a class="nav-item-link" href="/">主页</a></li><li class="nav-item"><a class="nav-item-link" href="/categories/%E6%96%87%E7%AB%A0">文章</a></li><li class="nav-item"><a class="nav-item-link" href="/categories/%E7%AC%94%E8%AE%B0">笔记</a></li><li class="nav-item"><a class="nav-item-link" href="/favorites">收藏</a></li><li class="nav-item"><a class="nav-item-link" href="/categories">类别</a></li><li class="nav-item"><a class="nav-item-link" href="/tags">标签</a></li><li class="nav-item"><a class="nav-item-link" href="/about">关于</a></li><li class="nav-item"><a class="nav-item-link nav-item-search" title="搜索"><i class="fe fe-search"></i> 搜索</a></li></ul></nav><nav class="navbar navbar-bottom"><ul class="nav"><li class="nav-item"><div class="totop" id="totop"><i class="fe fe-rocket"></i></div></li><li class="nav-item"><a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed"><i class="fe fe-feed"></i></a></li></ul></nav><div class="search-form-wrap"><div class="local-search local-search-plugin"><input type="search" id="local-search-input" class="local-search-input" placeholder="Search..."><div id="local-search-result" class="local-search-result"></div></div></div></aside><script src="/js/jquery-2.0.3.min.js"></script><script src="/js/jquery.justifiedGallery.min.js"></script><script src="/js/lazyload.min.js"></script><script src="/js/busuanzi-2.3.pure.min.js"></script><script src="/fancybox/jquery.fancybox.min.js"></script><script src="/js/tocbot.min.js"></script><script>tocbot.init({tocSelector:".tocbot",contentSelector:".article-entry",headingSelector:"h1, h2, h3, h4, h5, h6",hasInnerContainers:!0,scrollSmooth:!0,positionFixedSelector:".tocbot",positionFixedClass:"is-position-fixed",fixedSidebarOffset:"auto"})</script><script src="/js/ocean.js"></script></body></html>