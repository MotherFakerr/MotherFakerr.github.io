<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="MotherFaker的个人博客"><title>weakMap, weakSet, weakRef | MotherFaker的个人博客</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css"><script src="/js/pace.min.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="MotherFaker的个人博客" type="application/atom+xml">
</head><body><main class="content"><section class="outer"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous"><article id="post-2024-01-02-weakMap, weakSet, weakRef/2024-01-02-weakMap, weakSet, weakRef" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal><div class="article-inner"><header class="article-header"><h1 class="article-title" itemprop="name">weakMap, weakSet, weakRef</h1></header><div class="article-meta"><a href="/2024/01/02/2024-01-02-weakMap,%20weakSet,%20weakRef/2024-01-02-weakMap,%20weakSet,%20weakRef/" class="article-date"><time datetime="2024-01-02T15:22:00.000Z" itemprop="datePublished">2024-01-02</time></a><div class="article-category"><a class="article-category-link" href="/categories/%E6%96%87%E7%AB%A0/">文章</a></div></div><div class="tocbot"></div><div class="article-entry" itemprop="articleBody"><blockquote><p>前置知识文档：<a href="/2024/01/02/2024-01-02-%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%8C%E5%BC%B1%E5%BC%95%E7%94%A8/2024-01-02-%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%8C%E5%BC%B1%E5%BC%95%E7%94%A8/" title="强引用，弱引用">强&#x2F;弱引用传送门</a></p></blockquote><span id="more"></span><h1 id="一-weakmap"><a class="markdownIt-Anchor" href="#一-weakmap"></a> 一. weakMap</h1><h2 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h2><p>weakMap是弱引用版的Map，但有非常多的区别。</p><ol><li>weakMap对他的key是弱引用的，并且key必须得是对象，value则没有限制。</li><li>由于weakMap的key是弱引用，我们无法保证key中的某个字段是否已经被垃圾回收，因此weakMap无法对key进行遍历，其所自带方法也仅有delete、get、has、set。</li></ol><h2 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map();</span><br><span class="line">const weakMap = new WeakMap();</span><br><span class="line"></span><br><span class="line">(funtion example()&#123;</span><br><span class="line">  const k1 = &#123;x: 1&#125;;</span><br><span class="line">  const k2 = &#123;y: 2&#125;;</span><br><span class="line">  </span><br><span class="line">  map.set(k1, &#x27;k1&#x27;);</span><br><span class="line">  weakMap.set(k2, &#x27;k2&#x27;);</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">map.forEach((val, key) =&gt; console.log(key, val));</span><br><span class="line">// &#123;x: 1&#125;, &#x27;k1&#x27;</span><br></pre></td></tr></table></figure><p>上述例子初始化一个Map和一个weakMap，在立即执行函数中分别引用k1, k2所强引用的对象。当退出立即执行函数时，{x: 1}和{y: 2}<strong>失去了来自于变量k1，k2的强引用</strong>。此时{y: 2}<strong>仅存来自于weakMap的弱引用</strong>，因此，{y: 2}会被垃圾回收。而由于Map对其key值是强引用，因此Map中的内容会一直保存。</p><h2 id="使用场景cache"><a class="markdownIt-Anchor" href="#使用场景cache"></a> 使用场景：Cache</h2><img src="/2024/01/02/2024-01-02-weakMap, weakSet, weakRef/2024-01-02-weakMap, weakSet, weakRef/images/pasted-0.png"><p>在图1所示场景中，路由中间件内给weakMap添加了键值对作为缓存，在这个中间件内我们可以尽情的访问该键值对。而当我们退出这块代码块时完全不用担心内存问题，因为只要weakMap的key值不被全局变量强引用，这块缓存会被自动垃圾回收。</p><p>weakMap解决了缓存内存泄露的问题，但是仍有一些不方便的点，比如key值必须得是对象。如果我们想要通过访问简单类型比如string去获取到一些复杂数据时，可以采用Map+weakRef的形式（下述）。</p><h1 id="二-weakref"><a class="markdownIt-Anchor" href="#二-weakref"></a> 二. weakRef</h1><h2 id="概念-2"><a class="markdownIt-Anchor" href="#概念-2"></a> 概念</h2><p>weakRef对象允许我们对另一个对象产生弱引用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const ref = new WeakRef(object);</span><br><span class="line">// 在object外部包上WeakRef对象，并通过ref变量对该WeakRef对象强引用</span><br><span class="line">// 由于WeakRef对object是弱引用，当ref对其引用清除时，object会被垃圾回收</span><br><span class="line"></span><br><span class="line">const value = ref.deref();</span><br><span class="line">// 从WeakRef对象取出object原始值的方法，若object已被垃圾回收，返回undefined</span><br></pre></td></tr></table></figure><h2 id="使用场景复杂内容缓存"><a class="markdownIt-Anchor" href="#使用场景复杂内容缓存"></a> 使用场景：复杂内容缓存</h2><img src="/2024/01/02/2024-01-02-weakMap, weakSet, weakRef/2024-01-02-weakMap, weakSet, weakRef/images/pasted-1.png"><p>该场景实现了以{name: image}键值对缓存图像数据的方法，其中performExpensiveOperation()是一个开销巨大，且返回复杂对象的一个方法。通过将字符串name作为key，弱引用复杂对象image作为value的方式存入Map作为缓存。</p><p>当返回的image对象被函数外部引用时，再次调用该方法会直接返回Map中弱引用的对象。而当外部image对象不再引用，仅存Map对于image对象的弱引用时，该对象会被清除释放内存。</p><p>但是此时会有一个问题，当image弱引用对象被清除时，该键值对实际变成了{name: undefined}，image对象被回收，但是name字符串仍然存在。这种情况下可以使用伴随weakRef一起提出的终结器FinalizationRegistry。</p><h1 id="三-finalizationregistry"><a class="markdownIt-Anchor" href="#三-finalizationregistry"></a> 三. FinalizationRegistry</h1><h2 id="概念-3"><a class="markdownIt-Anchor" href="#概念-3"></a> 概念</h2><p>终结器绑定对象定义回调函数，会在该对象被垃圾回收后执行。</p><h2 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const registry = new FinalizationRegistry(value =&gt; &#123;</span><br><span class="line">		//…..</span><br><span class="line">	&#125;);</span><br><span class="line">registry.register(object, value);</span><br></pre></td></tr></table></figure><h2 id="场景"><a class="markdownIt-Anchor" href="#场景"></a> 场景</h2><p>下述例子解决了weakRef栏中name字段没有被清除的问题。<br><img src="/2024/01/02/2024-01-02-weakMap, weakSet, weakRef/2024-01-02-weakMap, weakSet, weakRef/images/pasted-2.png"></p><h1 id="四-weakset"><a class="markdownIt-Anchor" href="#四-weakset"></a> 四. weakSet</h1><h2 id="概念-4"><a class="markdownIt-Anchor" href="#概念-4"></a> 概念</h2><p>weakSet和Set的关系就好比weakMap和Map。weakSet对其中元素保持弱引用并且只能保存对象元素，weakSet仅有has，set，delete三个方法。</p><h2 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h2><p>目前没有发现特别适用于weakSet的使用场景，这玩意感觉没啥大用。</p><h1 id="五-使用建议"><a class="markdownIt-Anchor" href="#五-使用建议"></a> 五. 使用建议</h1><p>不建议！无法保证垃圾回收什么时候会运行，因此无法保证弱引用内容何时被清理。</p><blockquote><p><strong>来自MDN：GC在一个JavaScript引擎中的行为有可能在另一个JavaScript引擎中的行为大相径庭，或者甚至在同一类引擎，不同版本中GC的行为都有可能有较大的差距。</strong></p></blockquote></div><footer class="article-footer"><a data-url="https://motherfakerr.github.io/2024/01/02/2024-01-02-weakMap,%20weakSet,%20weakRef/2024-01-02-weakMap,%20weakSet,%20weakRef/" data-id="clrq183bf000d0cuoerikfay9" class="article-share-link">分享</a><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul></footer></div><nav class="article-nav"><a href="/2024/01/02/2024-01-02-%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%8C%E5%BC%B1%E5%BC%95%E7%94%A8/2024-01-02-%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%8C%E5%BC%B1%E5%BC%95%E7%94%A8/" class="article-nav-link"><strong class="article-nav-caption">前一篇</strong><div class="article-nav-title">强引用，弱引用</div></a><a href="/2023/06/14/2023-06-14-%E4%BD%BF%E7%94%A8hexo%E5%86%99%E6%96%87%E7%AB%A0/2023-06-14-%E4%BD%BF%E7%94%A8hexo%E5%86%99%E6%96%87%E7%AB%A0/" class="article-nav-link"><strong class="article-nav-caption">后一篇</strong><div class="article-nav-title">使用hexo写文章</div></a></nav></article></section><footer class="footer"><div class="outer"><ul class="list-inline"><li>MotherFaker的个人博客 &copy; 2024</li><li><a href="https://beian.miit.gov.cn/" target="_blank"></a></li><li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li><li>theme <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li></ul><p></p><ul class="list-inline"><li><i class="fe fe-smile-alt tooltip" data-tooltip="访客量"></i> <span id="busuanzi_value_site_uv"></span></li><li><i class="fe fe-bookmark tooltip" data-tooltip="点击量"></i> <span id="busuanzi_value_page_pv"></span></li></ul><p></p></div></footer></main><aside class="sidebar"><button class="navbar-toggle"></button><nav class="navbar"><div class="logo"><a href="/"><img src="/images/logo.png" alt="MotherFaker的个人博客"></a></div><ul class="nav nav-main"><li class="nav-item"><a class="nav-item-link" href="/">主页</a></li><li class="nav-item"><a class="nav-item-link" href="/categories/%E6%96%87%E7%AB%A0">文章</a></li><li class="nav-item"><a class="nav-item-link" href="/categories/%E7%AC%94%E8%AE%B0">笔记</a></li><li class="nav-item"><a class="nav-item-link" href="/favorites">收藏</a></li><li class="nav-item"><a class="nav-item-link" href="/categories">类别</a></li><li class="nav-item"><a class="nav-item-link" href="/tags">标签</a></li><li class="nav-item"><a class="nav-item-link" href="/about">关于</a></li><li class="nav-item"><a class="nav-item-link nav-item-search" title="搜索"><i class="fe fe-search"></i> 搜索</a></li></ul></nav><nav class="navbar navbar-bottom"><ul class="nav"><li class="nav-item"><div class="totop" id="totop"><i class="fe fe-rocket"></i></div></li><li class="nav-item"><a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed"><i class="fe fe-feed"></i></a></li></ul></nav><div class="search-form-wrap"><div class="local-search local-search-plugin"><input type="search" id="local-search-input" class="local-search-input" placeholder="Search..."><div id="local-search-result" class="local-search-result"></div></div></div></aside><script src="/js/jquery-2.0.3.min.js"></script><script src="/js/jquery.justifiedGallery.min.js"></script><script src="/js/lazyload.min.js"></script><script src="/js/busuanzi-2.3.pure.min.js"></script><script src="/fancybox/jquery.fancybox.min.js"></script><script src="/js/tocbot.min.js"></script><script>tocbot.init({tocSelector:".tocbot",contentSelector:".article-entry",headingSelector:"h1, h2, h3, h4, h5, h6",hasInnerContainers:!0,scrollSmooth:!0,positionFixedSelector:".tocbot",positionFixedClass:"is-position-fixed",fixedSidebarOffset:"auto"})</script><script src="/js/ocean.js"></script></body></html>