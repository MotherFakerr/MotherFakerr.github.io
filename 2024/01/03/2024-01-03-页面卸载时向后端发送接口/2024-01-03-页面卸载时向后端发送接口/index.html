<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="MotherFaker的个人博客"><title>页面卸载时向后端发送接口 | MotherFaker的个人博客</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css"><script src="/js/pace.min.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="MotherFaker的个人博客" type="application/atom+xml">
</head><body><main class="content"><section class="outer"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous"><article id="post-2024-01-03-页面卸载时向后端发送接口/2024-01-03-页面卸载时向后端发送接口" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal><div class="article-inner"><header class="article-header"><h1 class="article-title" itemprop="name">页面卸载时向后端发送接口</h1></header><div class="article-meta"><a href="/2024/01/03/2024-01-03-%E9%A1%B5%E9%9D%A2%E5%8D%B8%E8%BD%BD%E6%97%B6%E5%90%91%E5%90%8E%E7%AB%AF%E5%8F%91%E9%80%81%E6%8E%A5%E5%8F%A3/2024-01-03-%E9%A1%B5%E9%9D%A2%E5%8D%B8%E8%BD%BD%E6%97%B6%E5%90%91%E5%90%8E%E7%AB%AF%E5%8F%91%E9%80%81%E6%8E%A5%E5%8F%A3/" class="article-date"><time datetime="2024-01-02T16:06:00.000Z" itemprop="datePublished">2024-01-03</time></a><div class="article-category"><a class="article-category-link" href="/categories/%E6%96%87%E7%AB%A0/">文章</a></div></div><div class="tocbot"></div><div class="article-entry" itemprop="articleBody"><p>工作中遇到一个需求，需要在用户关闭或者刷新页面时向后端发送该用户的身份信息。</p><p>浏览器页面卸载时会触发beforeunload和unload事件，由于unload限制比较多，因此这里选择了beforeunload。</p><p><strong>问题</strong>：常用的异步ajax请求在unload/beforeunload事件内是不可靠的，浏览器可能会无视异步请求从而导致后端收不到。可以使用下述方法。</p><span id="more"></span><h1 id="1-同步ajax"><a class="markdownIt-Anchor" href="#1-同步ajax"></a> 1. 同步ajax</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#x27;beforeunload&#x27;, () =&gt; &#123;</span><br><span class="line">    const url = &#x27;test.com&#x27;;</span><br><span class="line">    const params = &#123; test : &#x27;test&#x27; &#125;; </span><br><span class="line">	$.ajax(&#123;</span><br><span class="line">        type: &#x27;POST&#x27;,</span><br><span class="line">        url: url,</span><br><span class="line">        data: params,</span><br><span class="line">        async: false</span><br><span class="line">    &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>同步ajax会阻断浏览器的unload，直到ajax环节结束后才会继续进行unload。</p><p>此方法的缺点是由于页面会在ajax请求结束后才延迟卸载，会导致关闭时浏览器出现卡顿降低用户的体验。</p><p><strong>注意：chrome不支持在页面关闭事件内使用同步XMLHttpRequest请求</strong></p><blockquote><p><a target="_blank" rel="noopener" href="https://chromestatus.com/feature/4664843055398912">Disallow sync XHR in page dismissal - Chrome Platform Status</a></p></blockquote><h1 id="2-beacon"><a class="markdownIt-Anchor" href="#2-beacon"></a> 2. beacon</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#x27;beforeunload&#x27;, () =&gt; &#123;</span><br><span class="line">    const url = &#x27;test.com&#x27;;</span><br><span class="line">    const params = &#123; test : &#x27;test&#x27; &#125;; </span><br><span class="line">	navigator.sendBeacon(url, JSON.stringfy(params));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>beacon api设计就是用来解决页面卸载时发送请求的问题。他能保证在页面unload完成前请求能够被发送，并且由于其是异步且非阻塞的，并不会影响浏览器其他页面的显示效率。</p><p>sendBeacon只能发送http post请求。</p><p>问题：此方法无法自定义header信息，如果服务端设置了token权限拦截，sendBeacon并没有办法将token信息放入请求中。</p><h1 id="3-fetch"><a class="markdownIt-Anchor" href="#3-fetch"></a> 3. fetch</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#x27;beforeunload&#x27;, () =&gt; &#123;</span><br><span class="line">    const url = &#x27;test.com&#x27;;</span><br><span class="line">    const params = &#123; test : &#x27;test&#x27; &#125;; </span><br><span class="line"></span><br><span class="line">    const headers = new Headers();</span><br><span class="line">    headers.append(&#x27;content-type&#x27;, &#x27;application/json&#x27;);</span><br><span class="line">    headers.append(&#x27;token&#x27;, &#x27;token&#x27;);        </span><br><span class="line">    </span><br><span class="line">    fetch(url, &#123;</span><br><span class="line">        method: &#x27;POST&#x27;,</span><br><span class="line">        headers: headers,</span><br><span class="line">        body: JSON.stringify(params),</span><br><span class="line">        // 重要！！！</span><br><span class="line">        keepalive: true,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>fetch方法配合参数中的<strong>keepalive</strong>字段会让浏览器在页面卸载后在后台继续接管网络请求，该字段是必须的。</p><p>此方法的缺陷为keepalive字段一次只能承载最大64KB的请求内容，且该限制是所有并行请求共享的，即，页面卸载阶段所有fetch+keepalive请求的内容体总和不能超过64KB。</p><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><blockquote><p><a target="_blank" rel="noopener" href="https://usefulangle.com/post/62/javascript-send-data-to-server-on-page-exit-reload-redirect">Sending AJAX Data when User Moves Away / Exits from Page</a><br><a target="_blank" rel="noopener" href="https://javascript.info/fetch-api">Fetch API</a><br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch">使用 Fetch - Web API 接口参考 | MDN</a><br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon">Navigator.sendBeacon() - Web API 接口参考 | MDN</a><br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/63157089/sending-post-request-with-fetch-after-closing-the-browser-with-beforeunload">javascript - Sending POST request with Fetch after closing the browser with ‘beforeunload’ / ‘unload’ eventlistener is not working - Stack Overflow</a></p></blockquote></div><footer class="article-footer"><a data-url="https://motherfakerr.github.io/2024/01/03/2024-01-03-%E9%A1%B5%E9%9D%A2%E5%8D%B8%E8%BD%BD%E6%97%B6%E5%90%91%E5%90%8E%E7%AB%AF%E5%8F%91%E9%80%81%E6%8E%A5%E5%8F%A3/2024-01-03-%E9%A1%B5%E9%9D%A2%E5%8D%B8%E8%BD%BD%E6%97%B6%E5%90%91%E5%90%8E%E7%AB%AF%E5%8F%91%E9%80%81%E6%8E%A5%E5%8F%A3/" data-id="clrq183bi000l0cuo4hm7ecq7" class="article-share-link">分享</a><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul></footer></div><nav class="article-nav"><a href="/2024/01/03/2024-01-03-bfcache%E5%A4%84%E7%90%86/2024-01-03-bfcache%E5%A4%84%E7%90%86/" class="article-nav-link"><strong class="article-nav-caption">前一篇</strong><div class="article-nav-title">bfcache处理</div></a><a href="/2024/01/02/2024-01-02-JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/2024-01-02-JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" class="article-nav-link"><strong class="article-nav-caption">后一篇</strong><div class="article-nav-title">JS 垃圾回收机制</div></a></nav></article></section><footer class="footer"><div class="outer"><ul class="list-inline"><li>MotherFaker的个人博客 &copy; 2024</li><li><a href="https://beian.miit.gov.cn/" target="_blank"></a></li><li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li><li>theme <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li></ul><p></p><ul class="list-inline"><li><i class="fe fe-smile-alt tooltip" data-tooltip="访客量"></i> <span id="busuanzi_value_site_uv"></span></li><li><i class="fe fe-bookmark tooltip" data-tooltip="点击量"></i> <span id="busuanzi_value_page_pv"></span></li></ul><p></p></div></footer></main><aside class="sidebar"><button class="navbar-toggle"></button><nav class="navbar"><div class="logo"><a href="/"><img src="/images/logo.png" alt="MotherFaker的个人博客"></a></div><ul class="nav nav-main"><li class="nav-item"><a class="nav-item-link" href="/">主页</a></li><li class="nav-item"><a class="nav-item-link" href="/categories/%E6%96%87%E7%AB%A0">文章</a></li><li class="nav-item"><a class="nav-item-link" href="/categories/%E7%AC%94%E8%AE%B0">笔记</a></li><li class="nav-item"><a class="nav-item-link" href="/favorites">收藏</a></li><li class="nav-item"><a class="nav-item-link" href="/categories">类别</a></li><li class="nav-item"><a class="nav-item-link" href="/tags">标签</a></li><li class="nav-item"><a class="nav-item-link" href="/about">关于</a></li><li class="nav-item"><a class="nav-item-link nav-item-search" title="搜索"><i class="fe fe-search"></i> 搜索</a></li></ul></nav><nav class="navbar navbar-bottom"><ul class="nav"><li class="nav-item"><div class="totop" id="totop"><i class="fe fe-rocket"></i></div></li><li class="nav-item"><a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed"><i class="fe fe-feed"></i></a></li></ul></nav><div class="search-form-wrap"><div class="local-search local-search-plugin"><input type="search" id="local-search-input" class="local-search-input" placeholder="Search..."><div id="local-search-result" class="local-search-result"></div></div></div></aside><script src="/js/jquery-2.0.3.min.js"></script><script src="/js/jquery.justifiedGallery.min.js"></script><script src="/js/lazyload.min.js"></script><script src="/js/busuanzi-2.3.pure.min.js"></script><script src="/fancybox/jquery.fancybox.min.js"></script><script src="/js/tocbot.min.js"></script><script>tocbot.init({tocSelector:".tocbot",contentSelector:".article-entry",headingSelector:"h1, h2, h3, h4, h5, h6",hasInnerContainers:!0,scrollSmooth:!0,positionFixedSelector:".tocbot",positionFixedClass:"is-position-fixed",fixedSidebarOffset:"auto"})</script><script src="/js/ocean.js"></script></body></html>